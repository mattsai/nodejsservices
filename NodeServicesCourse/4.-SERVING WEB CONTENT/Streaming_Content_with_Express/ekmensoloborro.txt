Streaming Content with Express
Express does not have native support for streams in the same way that Fastify does. However Express decorates the native HTTP IncomingMessage object (the response object, res). The res object is a writable stream, so this means we can essentially roll our own streaming response. However there are some complexities around this. For instance, when one stream is piped to another it will automatically end the destination stream when the source stream has ended. But in the case of an error, we don't want to end the response, we need to instead propagate the error back into Express so it can handle it centrally according to the configuration in app.js.

Making sure that our current working directory is the express-web-server folder as we left in the "Serving Static Content and Using Templates with Express" section, let's install hn-latest-stream: 

npm install hn-latest-stream 

Now, we'll create a new route:

cd routes
node -e "fs.openSync('articles.js', 'w')"

We need to register the router we'll be creating for routes/articles.js in the app.js file.

Near the top of the file there's currently two routers imported:

var indexRouter = require('./routes/index');
var helloRouter = require('./routes/hello');

We need to add an articlesRouter to this, that small section of app.js should be updated to look as follows:

var indexRouter = require('./routes/index');
var helloRouter = require('./routes/hello');
var articlesRouter = require('./routes/articles');

Around the middle of app.js the routers are registered. This currently looks as follows:

app.use('/', indexRouter);
app.use('/hello', helloRouter);

We need to add the articlesRouter mounted at the /articles route. That section should be updated to look like so:

app.use('/', indexRouter);
app.use('/hello', helloRouter);
app.use('/articles', articlesRouter);

The content of routes/articles.js should be as follows:

var express = require('express');
var router = express.Router();
var hnLatestStream = require('hn-latest-stream')
var finished = require('stream').finished

router.get('/', function(req, res, next) {
  const { amount = 10, type = 'html' } = req.query

  if (type === 'html') res.type('text/html')
  if (type === 'json') res.type('application/json')

  const stream = hnLatestStream(amount, type)

  stream.pipe(res, {end: false})

  finished(stream, (err) => {
    if (err) {
      next(err)
      return
    }
    res.end()
  })

});

module.exports = router;

The logic of the router handler is the same as in the previous section. We have a default amount of 10 and a default type of 'html' although this can be overridden by the query string of the incoming request URL. We also set the Content-Type HTTP header based on the type.

From there the code is slightly more complicated because we have to manually propagate errors and handle the dance of sending data without ending the response too soon.

The stream.pipe(res, {end: false}) line tells the stream (our Hacker News stream) to write all data it receives to the res object (which is also a stream). The second parameter, an object with a property named end set to false prevents pipe from performing its default behavior of endings the destination stream (res) when the source stream (stream) has ended. This is important because without this, if there is an error in the source stream then res will be ended before our server can send an appropriate error response.

Cont'd on the next page.